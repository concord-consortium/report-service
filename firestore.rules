// NOTE: to deploy only these rules run
// `firebase deploy --only firestore:rules`

// General Note:
// Based on this doc: https://firebase.google.com/docs/firestore/security/rules-conditions
//     For update operations that only modify a subset of the document fields,
//     the request.resource variable will contain the pending document state after the operation.
// So even if the client code uses an update to change some other property we can still verify that
// the pending document matches all of the correct identifying properties
// The token service has firebase tests with Jest
// The firestore rules library includes coverage testing:
//   https://firebase.google.com/docs/firestore/security/test-rules-emulator
// The emulator also shows errors in the rules

// initially lock out all client access to all documents
// the plan will be to open up client access as the schema is developed
// note: firestore functions can still access anything by default
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }

    match /sources/{source}/resources/{document=**} {
      // allows anonymous user to get the resource structure
      allow read: if true;
    }

    function teacherOfContext() {
      return request.auth.token.user_type == 'teacher'
        && request.auth.token.class_hash == resource.data.context_id
        // The context_id is scoped to the platform_id
        && request.auth.token.platform_id == resource.data.platform_id;
    }

    // Note: this conditional is used in read rules, which do not require a
    // matching context_id, so the context_id is not enforced here
    function learnerOwner(res) {
      return request.auth.token.user_type == 'learner'
        && string(request.auth.token.platform_user_id) == string(res.data.platform_user_id)
        && request.auth.token.platform_id == res.data.platform_id;
    }

    function notChangingIdentifyingProps() {
      // Make sure the learner isn't changing the document's identifying properties
      return string(request.resource.data.platform_user_id) == string(request.auth.token.platform_user_id)
        && request.resource.data.platform_id == request.auth.token.platform_id
        // If for some reason the learner got a hold of a document from outside of their
        // current class don't let them update it
        && request.resource.data.context_id == request.auth.token.class_hash
        // Make sure the learner isn't changing the current document's id
        && request.resource.data.context_id == resource.data.context_id;
    }

    // This is similar to learnerOwner, we are using request.resource
    // because there is no existing resource to look at, and we can enforce
    // the context_id matches the auth info
    function learnerOwnerCreate() {
      return learnerOwner(request.resource)
        // Make sure the document will be in the correct class
        && request.auth.token.class_hash == request.resource.data.context_id;
    }

    // Security: the update and create rules allow any anonymous user to write almost any
    //   content they want. The key bit is the requirement that the platform_id is not
    //   set.  So long as other other rules check for this platform_id, then we can be
    //   sure that anonymous users don't inject documents into authenticated query results.

    // Anonymous Reports: these update and create rules allow a user to write any data
    //   except for platform_id.
    //   So in the future the activity player could support a resource_link_id with anonymous users.
    //   This would let a teacher correlate multiple students running from a single
    //   link that they posted to their LMS.

    // Possible improvement: our 'run_key' essentially represents
    //   (platform_id, platform_user_id, resource_link_id)
    //   So we might be able to simplify some of the logic here by using those
    //   3 properties instead of a run_key
    //   The platform_id could be left null or be a fixed string like "anonymous".
    //   The platform_user_id could be the randomly generated 'run_key'
    //   The resource_link_id would be an optional randomly generated id that can correlate
    //   multiple platform_users so a teacher gets an anonymous class report.

    function anonymousCreate() {
      return request.resource.data.run_key.size() > 10
        // Make sure anonymous answers don't have platform_ids
        && !('platform_id' in request.resource.data);
    }

    // Anyone can read any anonymous docs with a 'valid' run_key
    function anonymousRead() {
      return resource.data.run_key.size() > 10
    }

    function anonymousUpdate() {
      return resource.data.run_key.size() > 10
        // Make sure they can't change the run key of an existing document
        && resource.data.run_key == request.resource.data.run_key
        // Make sure anonymous answers don't have platform_ids
        && !('platform_id' in request.resource.data);
    }

    function studentWorkCreate() {
      return anonymousCreate()
        || learnerOwnerCreate();
    }

    function studentWorkRead() {
      return anonymousRead()
        || teacherOfContext()
        || learnerOwner(resource);
    }

    function studentWorkUpdate() {
      return anonymousUpdate()
        || (learnerOwner(resource) && notChangingIdentifyingProps());
    }

    match /sources/{source}/answers/{document=**} {
      allow create: if studentWorkCreate();
      allow read: if studentWorkRead();
      allow update: if studentWorkUpdate();
    }

    match /sources/{source}/plugin_states/{document=**} {
      allow create: if studentWorkCreate();
      allow read: if studentWorkRead();
      allow update: if studentWorkUpdate();
    }

    // This is a collection in which users can write their own documents
    // Security: the path here is what restricts access. But we are only checking
    //   the user_id. I think the source in this case matches the platform_id so
    //   we can check that (if we can convert it), or perhaps the platform_id is
    //   written into the documents so we should check that too
    //
    // Anonymous Reports: we could just not allow report settings saving
    //   however this might cause problems in the portal-report code
    match /sources/{source}/user_settings/{user_id}/resource_link/{document=**} {
      allow read, create, update: if request.auth.token.user_type == 'teacher' &&
        string(request.auth.token.platform_user_id) == string(user_id);
    }

    // This let us test the report settings with fake portal data:
    match /sources/fake.portal/user_settings/1/resource_link/1 {
      allow read, create, update: if true;
    }

    function feedbackCreate() {
      return request.auth.token.user_type == 'teacher'
        // Make sure teachers can only update feedbacks from their own contexts
        // Note this uses camel case instead of snake case
        && request.auth.token.platform_id == request.resource.data.platformId
        && request.auth.token.class_hash == request.resource.data.contextId;
    }

    function teacherFeedbackRead() {
      return request.auth.token.user_type == 'teacher'
        && request.auth.token.platform_id == resource.data.platformId
        && request.auth.token.class_hash == resource.data.contextId;
    }

    function learnerFeedbackRead() {
      return request.auth.token.user_type == 'learner'
        && string(request.auth.token.platform_user_id) == string(resource.data.platformStudentId)
        && request.auth.token.platform_id == resource.data.platformId;
    }

    function feedbackRead() {
      return teacherFeedbackRead() || learnerFeedbackRead();
    }

    function feedbackUpdate() {
      return request.auth.token.user_type == 'teacher'
        && request.auth.token.platform_id == resource.data.platformId
        && request.auth.token.platform_id == request.resource.data.platformId
        && request.auth.token.class_hash == resource.data.contextId
        && request.auth.token.class_hash == request.resource.data.contextId;
    }

    // Feedbacks
    match /sources/{source}/question_feedbacks/{document=**} {
      allow create: if feedbackCreate();
      allow read: if feedbackRead();
      allow update: if feedbackUpdate();

      // To support anonymous users we'd need a new read option that matches a context_id, resource_link_id, and run_key
      // One of the reasons to support anonymous feedback is to simplify testing, but if the data and code paths
      // for this anonymous feedback is different it won't be as good for testing.
      // So maybe we should switch from a run_key to a special platform_user_id that starts with a
      // fake domain like https://activities.concord.org/anonymous/{run_key}
      // If we follow that to its conclusion would also allow students/teachers to re-use the
      // same anonymous platform_user_id for multiple anonymous assignments. There isn't a great
      // reason to use this right away, but it would match the current logged in case better.
      // And in the future it would allow anonymous teachers to correlate data across multiple assignments
      // for a single student. The issue is that most LMS would not support something like this
      // out of the box. They'd need some option which lets the user supply a template for the URL which
      // the LMS then populates with a student id. So using generic LMS support the student would need
      // to know their special id and paste it into some field when they run the activity.
    }

    // The same comments above apply here
    match /sources/{source}/activity_feedbacks/{document=**} {
      allow create: if feedbackCreate();
      allow read: if feedbackRead();
      allow update: if feedbackUpdate();
    }

    // Anonymous Reports:
    //   We'll need a teacher giving anonymous feedback to be able to write documents like this. Assuming
    //   the documents are named based on resource_link_id that is another good reason to require that id
    //   in the params when the student and teacher are running anonymously.
    match /sources/{source}/feedback_settings/{document=**} {
      allow create: if feedbackCreate();
      allow read: if feedbackRead();
      allow update: if feedbackUpdate();
    }

    // This let us test the report feedback with fake portal data:
    match /sources/fake.authoring.system/question_feedbacks/{document=**} {
      allow read, create, update: if true;
    }
    match /sources/fake.authoring.system/activity_feedbacks/{document=**} {
      allow read, create, update: if true;
    }
    match /sources/fake.authoring.system/feedback_settings/{document=**} {
      allow read, create, update: if true;
    }
  }
}
